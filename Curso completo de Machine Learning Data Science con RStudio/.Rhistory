remove(data.clean)
data.cleaned.2 <- data[complete.cases(data),]
View(data.cleaned.2)
# Convertir los 0 de Incoming en NA
data$Income[data$Income == 0]
# Convertir los 0 de Incoming en NA
data$Income[data$Income == 0] <- NA
View(data)
### Medidas de centralización y dispersión
# mean() = para sacar el promedio
mean(data$Income)
# na.rm = T, omitirá los registros NA
mean(data$Income, na.rm = T)
# sd(), Desviación estandar (Disperción)
sd(data$Income)
sd(data$Income, na.rm = T)
data <- read.csv("data/tema1/missing-data.csv")
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
View(data)
# Para crear una columna nueva, basta con ingresar al data frame con $ y posteriormente poner el nombre que deseemos en este caso $Income.mean
data$Income.mean <- ifelse(is.na(data$Income),
mean(data$Income, na.rm = TRUE),
data$Income)
View(data)
# x, es un vector de datos que puede contener NA
random.impute <- function(x){
# missing, vector del mismo tamaño que x pero con valores booleanos
missing <- is.na(x)
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolverá cuantos son TRUE
n.missing <- sum(missing)
#x.obs contendrá los valores diferentes de NA en x
x.obs <- x[!missing]
# Por defecto, se devolverá la misma información que ingresó a la función
inputed <- x
# Los valores NA se reemplazarán por una muestra aleatoria, de los datos conocidos x.obs
# n.missing, le indicará a sample(), cuantos debe de reemplazar
inputed[missing] <- sample(x.obs, n.missing, replace = T)
return (imputed)
}
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] <- random.impute(dataframe[,col])
}
}
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
random.impute.data.frame(data, c(1,2))
random.impute.data.frame(data, c(1,2))
name <- paste(names[col], "impute", sep = ".")
random.impute.data.frame(data, c(1,2))
name <- paste(names[col], "impute", sep = ".")
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolverá cuantos son TRUE
n.missing <- sum(missing)
random.impute.data.frame(data, c(1,2))
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolverá cuantos son TRUE
n.missing <- sum(missing)
View(data)
# x, es un vector de datos que puede contener NA
random.impute <- function(x){
# missing, vector del mismo tamaño que x pero con valores booleanos
missing <- is.na(x)
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolverá cuantos son TRUE
n.missing <- sum(missing)
#x.obs contendrá los valores diferentes de NA en x
x.obs <- x[!missing]
# Por defecto, se devolverá la misma información que ingresó a la función
inputed <- x
# Los valores NA se reemplazarán por una muestra aleatoria, de los datos conocidos x.obs
# n.missing, le indicará a sample(), cuantos debe de reemplazar
inputed[missing] <- sample(x.obs, n.missing, replace = T)
return (imputed)
}
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] <- random.impute(dataframe[,col])
}
}
random.impute.data.frame(data, c(1,2))
# Para crear una columna nueva, basta con ingresar al data frame con $ y posteriormente poner el nombre que deseemos en este caso $Income.mean
data$Income.mean <- ifelse(is.na(data$Income),
mean(data$Income, na.rm = TRUE),
data$Income)
random.impute.data.frame(data, c(1,2))
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
random.impute.data.frame(data, c(1,2))
inputed <- x
View(random.impute)
View(random.impute)
View(random.impute)
View(random.impute)
View(random.impute)
View(random.impute)
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
#x es un vector de datos que puede contener NA
rand.impute <- function(x) {
# missing contiene un vector de valores T/F dependiendo del NA de x
missing <- is.na(x)
#n.missing contiene cuantos valores son NA dentro de x
n.missing <- sum(missing)
#x.obs son los valores conocidos que tienen dato diferente de NA en x
x.obs <- x[!missing]
#por defecto, devolveré lo mismo que había entrado por parámetro
imputed <- x
#en los valores que faltaban, los reemplazamos por una muestra
#de los que si conocemos (MAS)
imputed[missing] <- sample(x.obs, n.missing, replace = TRUE)
return (imputed)
}
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] = rand.impute(dataframe[,col])
}
dataframe
}
random.impute.data.frame(data, c(1,2))
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
random.impute <- function(x){
# missing, vector del mismo tamaño que x pero con valores booleanos
missing <- is.na(x)
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolvera cuantos son TRUE
n.missing <- sum(missing)
#x.obs contendra los valores diferentes de NA en x
x.obs <- x[!missing]
# Por defecto, se devolvera la misma información que ingresó a la funcion
inputed <- x
# Los valores NA se reemplazaran por una muestra aleatoria, de los datos conocidos x.obs
# n.missing, le indicará a sample(), cuantos debe de reemplazar
inputed[missing] <- sample(x.obs, n.missing, replace = T)
return (imputed)
}
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] <- random.impute(dataframe[,col])
}
}
random.impute.data.frame(data, c(1,2))
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
# x, es un vector de datos que puede contener NA
random.impute <- function(x){
# missing, vector del mismo tamaño que x pero con valores booleanos
missing <- is.na(x)
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolverá cuantos son TRUE
n.missing <- sum(missing)
#x.obs contendrá los valores diferentes de NA en x
x.obs <- x[!missing]
# Por defecto, se devolverá la misma información que ingresó a la función
imputed <- x
# Los valores NA se reemplazarán por una muestra aleatoria, de los datos conocidos x.obs
# n.missing, le indicará a sample(), cuantos debe de reemplazar
inputed[missing] <- sample(x.obs, n.missing, replace = T)
return (imputed)
}
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] <- random.impute(dataframe[,col])
}
}
random.impute.data.frame(data, c(1,2))
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
# x, es un vector de datos que puede contener NA
random.impute <- function(x){
# missing, vector del mismo tamaño que x pero con valores booleanos
missing <- is.na(x)
# n.missing contiene cuantos valores son NA
# sum(), al sumar un vector de booleanos este nos devolverá cuantos son TRUE
n.missing <- sum(missing)
#x.obs contendrá los valores diferentes de NA en x
x.obs <- x[!missing]
# Por defecto, se devolverá la misma información que ingresó a la función
imputed <- x
# Los valores NA se reemplazarán por una muestra aleatoria, de los datos conocidos x.obs
# n.missing, le indicará a sample(), cuantos debe de reemplazar
imputed[missing] <- sample(x.obs, n.missing, replace = T)
return (imputed)
}
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] <- random.impute(dataframe[,col])
}
}
random.impute.data.frame(data, c(1,2))
View(data)
random.impute.data.frame <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "imputed", sep = ".")
dataframe[name] <- random.impute(dataframe[,col])
}
dataframe
}
random.impute.data.frame(data, c(1,2))
View(data)
data <- random.impute.data.frame(data, c(1,2))
data <- read.csv("data/tema1/missing-data.csv", na.strings = "")
data$Income[data$Income == 0] <- NA
data <- random.impute.data.frame(data, c(1,2))
View(data)
family.salary <- c(40000, 60000, 50000, 80000, 60000, 70000, 60000)
family.size <- c(4, 3, 2, 2, 3, 4, 3)
family.car <- c("Lujo", "Compacto", "Utilitario", "Lujo", "Compacto", "Compacto", "Compacto")
family.data.frame <- data.frame(family.salary, family.size, family.car)
View(family.data.frame)
unique(family)
family.salary <- c(40000, 60000, 50000, 80000, 60000, 70000, 60000)
family.size <- c(4, 3, 2, 2, 3, 4, 3)
family.car <- c("Lujo", "Compacto", "Utilitario", "Lujo", "Compacto", "Compacto", "Compacto")
family<- data.frame(family.salary, family.size, family.car)
unique(family)
family.unique <- unique(family)
View(family.unique)
duplicated(family)
family[duplicated(family),]
install.packages("scales")
# install.packages("scales")
library(scales)
# install.packages("scales")
library(scales)
students <- read.csv("data/tema1/data-conversion.csv")
View(students)
# Para reescalar una variable, darán valores entre 0 y 1
students$Income.rescaled <- rescale(students$Income)
(students$Income - min(students$Income))/(max(students$Income) - min(students$Income))
# Si queremos tener un rango distinto como porcentaje, eje: entre 0 y 100
rescale(students$Income, to = c(0, 100))
rescale.many <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "rescaled", sep = ".")
dataframe[name] <- rescale(dataframe[,col])
}
# cat(), para imprimir por consola
cat(paste("Hemos reescalado", length(cols), "variables()"))
dataframe
}
students <- rescale.many(students, col(1,4))
students <- rescale.many(students, c(1,4))
View(students)
# Pagina del data set, donde se explican las variables https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html
housing <- read.csv("data/tema1/BostonHousing.csv")
View(housing)
# Para normalizar datos númericos no más
housing.z <- scale(housing)
View(housing.z)
housing.none <- scale(housing, center = F, scale = F)
housing.mean <- scale(housing, center = T, scale = F)
View(housing.mean)
housing.sd <- scale(housing, center = F, scale = T)
View(housing.sd)
# Cuando se hace uso de la normalización es común usar z como prefijo
scale.many <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col,], "z", sep = ".")
dataframe[name] <- scale(dataframe[, col])
}
cat(paste("Hemos normalizado "), length(cols)," variable(s)")
dataframe
}
housing <- scale.many(housing, c(1, 3, 5:8))
any
housing <- scale.many(housing, c(1, 3, 5:8))
# Cuando se hace uso de la normalización es común usar z como prefijo
scale.many <- function(dataframe, cols){
names <- names(dataframe)
for(col in cols){
name <- paste(names[col], "z", sep = ".")
dataframe[name] <- scale(dataframe[, col])
}
cat(paste("Hemos normalizado "), length(cols)," variable(s)")
dataframe
}
housing <- scale.many(housing, c(1, 3, 5:8))
View(housing)
students <- read.csv("data/tema1/data-conversion.csv")
students$Income.car <- cut(students$Income, beaks = bp, labels = names)
students$Income.car <- cut(students$Income, breaks = bp, labels = names)
#Inf, representa a infinito
bp <- c(-Inf, 10000, 31000, Inf)
names <- c("Low", "Average", "High")
students$Income.car <- cut(students$Income, breaks = bp, labels = names)
View(students)
# Para no poner etiquetas
students$Income.cat2 <- cut(students$Income, breaks = bp)
# Le indico a cut() que se harán 4 cortes y le envio las etiquetas, R gestionará automaticamente
students$Income.cat3 <- cut(students$Income, breaks = 4,
labels = c("Level 1", "Level 2", "Level 3", "Level 4"))
students <- read.csv("data/tema1/data-conversion.csv")
install.packages("dummies")
students.dummy <- dummy.data.frame(students, sep = ".")
# Trabajando con Dummy variables
students <- read.csv("data/tema1/data-conversion.csv")
students.dummy <- dummy.data.frame(students, sep = ".")
# install.packages("dummies")
library(dummies)
# Trabajando con Dummy variables
students <- read.csv("data/tema1/data-conversion.csv")
# install.packages("dummies")
library(dummies)
students.dummy <- dummy.data.frame(students, sep = ".")
names(students.dummy)
View(students.dummy)
# dummy.data.frame(), crea variables dummy para las variables categoricas (Strings)
students.dummy <- dummy.data.frame(students, sep = ".", all = F)
View(students.dummy)
# dummy.data.frame(), crea variables dummy para las variables categoricas (Strings)
# Si se utiliza el parametro all = FALSE, nos devolverá solo las variables dummy
students.dummy <- dummy.data.frame(students, sep = ".")
names(students.dummy)
dummy(students$State)
# tambien podemos usar el parametro names, para atacar a un subconjunto, en el especificamos los nombres de las columnas
dummy.data.frame(students, names = c("State", "Gender"), sep = ".")
hounsing.data <- read.csv("data/tema1/housing-with-missing-value.csv",
header = T, stringsAsFactors = F)
View(hounsing.data)
hounsing.data <- read.csv("data/tema1/housing-with-missing-value.csv",
header = T)
hounsing.data <- read.csv("data/tema1/housing-with-missing-value.csv",
header = T, stringsAsFactors = F)
summary(hounsing.data)
### FORMA 1
hounsing.data.1 <- na.omit(hounsing.data)
summary(hounsing.data.1)
### FORMA 2
# Eliminar los NA de ciertas columnas (Filtrado selectivo)
drop_na <- c("rad")
housing.data <- read.csv("data/tema1/housing-with-missing-value.csv",
header = T, stringsAsFactors = F)
# Quartil, sumarry() muestra 1st Qu. vendria ser el punto 25%
# la media vendria a ser el 2do Qu. que representaría al 50%
# Y el 3er Qu. el 75%
summary(hounsing.data)
### FORMA 1
# Elimina todas las observaciones que contengan un NA
housing.data.1 <- na.omit(hounsing.data)
### FORMA 1
# Elimina todas las observaciones que contengan un NA
housing.data.1 <- na.omit(housing.data)
# Devuelve todas las filas donde la columna rad no sea NA
housing.data.2 <- housing.data[complete.cases(housing.data[,!(names(housing.data))%in% drop_na]),]
### FORMA 2
# Eliminar los NA de ciertas columnas (Filtrado selectivo)
drop_na <- c("rad")
# Devuelve todas las filas donde la columna rad no sea NA
housing.data.2 <- housing.data[complete.cases(housing.data[,!(names(housing.data))%in% drop_na]),]
View(housing.data.2)
summary(housing.data.2)
### FORMA 3
# Eliminar toda una columna
housing.data$rad <- NULL
summary(housing.data)
housing.data <- read.csv("data/tema1/housing-with-missing-value.csv",
header = T, stringsAsFactors = F)
housing.data.3 <- housing.data[,!name(housing.data)%in% drops]
# Para eliminar mas de una variable
drops <- c("rad", "ptratio")
housing.data.3 <- housing.data[,!name(housing.data)%in% drops]
housing.data.3 <- housing.data[,!names(housing.data)%in% drops]
summary(housing.data.3)
###### FORMAS PARA COMPLETAR INFORMACION ######
install.packages("Hmisc")
###### FORMAS PARA COMPLETAR INFORMACION ######
# install.packages("Hmisc")
library(Hmisc)
###### FORMAS PARA COMPLETAR INFORMACION ######
# install.packages("Hmisc")
library(Hmisc)
housing.data <- read.csv("data/tema1/housing-with-missing-value.csv",
header = T, stringsAsFactors = F)
# Reemplazar los NA por valores conocidos
housing.data.copy <- housing.data
# Reemplazar los NA por valores conocidos
housing.data.copy1 <- housing.data
# Reemplazar los valores de ptratio por el promedio de la misma
housing.data.copy1$ptratio <- impute(housing.data.copy1$ptratio, mean)
housing.data.copy1$rad <- impute(housing.data.copy1$rad, mean)
summary(housing.data.copy1)
housing.data.copy2 <- housing.data
# Reemplazar los valores de ptratio y rad por la media de la misma respectivamente
housing.data.copy2$ptratio <- impute(housing.data.copy1$ptratio, median)
housing.data.copy2$rad <- impute(housing.data.copy1$rad, median)
summary(housing.data.copy2)
housing.data.copy3 <- housing.data
housing.data.copy3$rad <- impute(housing.data.copy3$rad, 7)
summary(housing.data.copy3)
# Para reemplazar por una constante
housing.data.copy3 <- housing.data
housing.data.copy3$ptratio <- impute(housing.data.copy3$ptratio, 18)
housing.data.copy3$ptratio <- impute(housing.data.copy3$ptratio, 18)
housing.data.copy3$rad <- impute(housing.data.copy3$rad, 7)
summary(housing.data.copy3)
install.packages("mice")
# install.packages("mice")
library(mice)
md.pattern(housing.data)
install.packages("VIM")
# install.packages("VIM")
library(VIM)
aggr(housing.data)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col, nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
aggr(housing.data, col = c('green', 'red'))
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col, nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
aggr(housing.data, col = c('green', 'red'), numbers = T)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col, nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers, nos muestra los porcentajes (las probabilidades) de datos
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data))
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 0.5)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 0.7)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 5.7)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 0.7)
5
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 5.7)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 0.7)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 0.7, gap = 1)
# Diagrama bi color, para datos conocidos y no conocidos
# El parametro col (vector), nos deja definir los colores deseados, el primer color representa a los valores conocidos y el segundo a los valores no conocidos
# El parametro numbers (boolean), nos muestra los porcentajes (las probabilidades) de datos
# El parametro sortVars (boolean), nos ordena las variables faltantes de  mayor a menor
# El parametro labels (vector), en el prodremos especificar nombres de las etiquetas a mostrar en los graficos
# El parametro cex.axis (decimal), nos permitirá cambiar el tamaño de la fuente en los ejes
# El parametro gap (integer), nos permitirá aumentar o reducir el tamaño entre los gráficos
aggr(housing.data, col = c('green', 'red'), numbers = T, sortVars = T,
labels = names(housing.data), cex.axis = 0.7, gap = 1,
ylab =c("Histograma de NAs", "Patrón") )
summary(housing.data.copy1)
install.packages("tidyr")
install.packages("tidyr")
# install.packages("tidyr")
library(tidyr)
crime.data <- read.csv("data/tema1/USArrests.csv")
View(crime.data)
crime.data <- read.csv("data/tema1/USArrests.csv", stringsAsFactors = F)
View(crime.data)
# cbind(), sirve para añadir una o mas columnas a data frame original
crime.data <- cbind(state = rownames(crime.data), crime.data)
View(crime.data)
